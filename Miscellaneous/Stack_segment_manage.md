1. 堆区的构成：

逻辑上堆由大小不同的块构成，每个块要么是分配或空间的，每个进程维护brk指针指向堆顶(所有初始化的数据区域之上)

2. 堆区如何内存分配？

c标准库提供malloc函数从堆中分配块—调用mmap()映射page或者sbrk()使brk指针增减

3. 分配器如何识别空闲块？

   使用隐式空闲链表：每一块块头增加块大小和已分配位，通过块大小可以使分配器遍历整个堆，再通过分配为找出一空闲的大小足够的块分配

4. 空闲链表的管理？

   存在分配位置，分割空闲块，合并空闲块的问题，可以参考操作系统`Chapter8`中的可变分区分配内存策略

5. malloc操作是会自行上锁的，所以不用担心多线程访问问题

6. New/delete

   New/delete为c++提供的运算符，由于对于非内置的数据类型，我们不仅希望动态的分配内存，还希望完成构造和析构，而malloc为库函数又无法被编译器控制，所以实现了new/delete实现内存分配和构造的运算符

   **注：对于数组资源：delete[]，使得每个元素都析构

