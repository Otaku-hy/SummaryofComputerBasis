## 指令系统

### 1.CISC RISC指令集的特征

CISC： 

1. 软件硬化：使用一条指令代替一串指令的功能

   2. 使用复杂寻址方式支持高级语言

   3. 其软件的兼容

      disadv：

      1. 运行速度慢
      2. 编译难度高
      3. 大部分指令不常用，使计算机难以维护

RISC：

1. 只使用简单指令，寻址方式简单

2. 通用寄存器数量多，只是用load，store读取寄存器
3. 方便编译优化

### 2. 指令系统应具备的内容

1. 操作数：硬件可以直接识别的数据类型；一般为地址，数字，字符，逻辑数（无符号型）

2. 地址空间：通用寄存器组，主存，IO设备均需要编址以进行访问：

   1. 三种独立编址：广泛使用
   2. 主存，IO统一编址：CISC浪费了处理主存的复杂指令；RISC同理，对其L/S指令浪费，但也有RISC使用这种编址
   3. 三种统一编址：方便

3. 编址方式：

   按字编址：访问主存以1字为单位，主存容量：存储字数X存储字长。
   					但这种方式不方便处理字节运算

   按字节编址：常用的一种方式，访问主存既可按字节，又可按字，但有两点需要注意：

   	1. 编制顺序：小端法：低字节低地址高字节高地址；大端法：与小端相反
   	2. 数据对其方式：一般考虑对于n字节的数据，其存储起始地址为n的整数倍

4. 指令类型：数据传送；数据运算；程序控制；IO；其他

### 3. 指令格式

1. 指令组成：操作码+地址码

   a. 操作码包含操作类型以及所用操作数类型，eg：movq

   b. 地址码

   ​	地址码与CPU结构以及指令格式有关：目前CPU为通用寄存器型结构，所有有RS型指令，RR型指令；同时不同个数元操作数（源操作数目的操作数个数）会产生1地址，2地址，3地址三种形式

2. 操作码拓展技术

   操作码分为定长操作码和变长操作码，变长操作码主要用于压缩操作码平均长度

   操作码拓展是变长操作码的一种形式，其思想为。在多地址码结构混合使用时，在使用地址码较少的指令的地址码多余字段增加为操作码的一部分：

   常见的有等长拓展法（15-15-15-16等）和不等长拓展法

在现代计算机中，指令格式还和寻址方式有关，一般对于一个地址码来说，其还要在内安排几位标志位表明寻址方式：

![instruction_sturcture](./images/instruction_sturcture.png)

### 4. 寻址方式

获得操作数在存储设备中具体地址的方式为寻址方式。

1. 立即寻址：

   OP | MOD | I

   立即寻址的操作数由指令直接给出，其中操作数是有符号数，范围有限

2. 寄存器寻址

   OP | MOD | R~i~

   寄存器寻址的操作数存在寄存器中，大小为寄存器的最大位数

3. 存储器寻址

   a. 直接寻址

   OP | MOD | A

   直接寻址的形式地址就是操作数在存储器中的地址，即EA = A。A为无符号数，范围有限

   b. 间接寻址

   OP | MOD | A

   简介寻址的形式地址是指示操作数地址的单元在存储器中的地址，即EA = (A)。其寻址范围为主存字长。当然还有另外的二次间接寻址，即在对一次间接寻址的地址在存储器中寻找其对应单元，此时存储器所存内容中需要额外一位判断寻址是否结束，则寻址范围变为一次间接的一半

   c. 寄存器间接寻址

   OP | MOD | R~i~

   寄存器间接寻址中R~i~寄存器中的数据就是操作数的有效地址，即EA = (R~i~)

   d. 偏移寻址

   OP | MOD | R~i~ | A

   偏移寻址又分为三种：相对寻址，变址寻址，基址寻址

   相对寻址R~i~使用PC寄存器，A表示偏移量，根据其A的位数k。相对寻址可以寻找(PC) - 2^k-1^~ (PC) + 2^k-1^-1范围内的指令（由于相对寻址只能使用PC寄存器所以A位数可包括R~i~位数）

   变址寻址R~i~使用变址或通用寄存器，A给出基址，为无符号数。R~i~给出偏移地址（为有符号数）。多用于数组，字符串访问

   基址寻址R~i~使用基址或通用寄存器，A给出偏移量，为有符号数。R~i~给出基址。多用于程序段的加载，定位

   e. 段寻址

   在基址寻址的基础上增加段跨越前缀

4. 堆栈寻址

   该存储方式通过PUSH POP操作堆栈段实现。在IA32中，栈底高地址，栈向低地址生长，sp指向非空单元

5. 复合寻址

   上述若干几种寻址方式的结合

### 5. 程序定位

主要分为静态定位和动态定位，这两种方式都需要在编译时指定代码的逻辑地址空间，接着分别在加载时和运行时进行重定位
