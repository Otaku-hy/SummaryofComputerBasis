1. 交换：由于实际内存有限，我们不可能把所有进程装载进入内存。这时候我们需要在内存紧张时，使用一种**交换**技术，将部分进程换出内存，在将需要的进程换入内存

   **注：所有进程PCB都存放在系统内存区，当某进程将执行时，如果其进程不在内存中则将其换入内存

2. 连续内存分配：给每个进程连续的内存

   a. 单一连续分配：将内存用户区完全分配给一个进程

   ​	无外部碎片，但内部碎片很大

   b. 固定多分区：将内存分成多个大小固定（可不同）的分区

   ​	无外部碎片，有内部碎片

   c. 可变分区（动态分区）— 可用于GPU momery资源的管理：

   ​	维护一空闲内存表，按照一定的算法为进程分配他需要的空间，注意分区的分配和回收

   ​	算法：**首次适应**：按首地址排序，每次从头找第一个满足的 写了一个例子`continousMemory`

   ​				**最佳适应**：按小大排序，每次找最小的满足的

   ​				**最差适应**：按大小排序，每次找最大的满足的

   ​				**临近适应**：按首地址排序，每次从上次分配的位置开始查找

   \**注：**外部碎片**：进程的memory分配造成的内存中未分配的较小的内存空间，这些空闲空间无法满足任何进程的需求，故资源浪费。这种浪费可以通过**紧缩**解决

   ​			**内部碎片**：给一个进程分配的内存比他实际需要的大，造成了进程内部的内存浪费

3. 分段分配：从用户的角度将程序的逻辑地址空间分成不同的段（e.g. 数据段，堆栈段，代码段）

   地址结构：段号 +段内地址 e.g. |16bits| + |16bits|

   硬件支持：段表—每个条目为逻辑段对应的物理存储的基地址和段界限（段长）

   地址转换：由段号通过段表条目寻找对应的物理段存储基地址，再检查是否越界，最后物理地址为：基地址 + 段内地址

4. 分页分配：把逻辑地址空间分page，把物理内存分frame，将整个进程可不连续的分配到内存中

   地址结构：页码+页偏移

   页表：每一条目记录了page号相对应的frame号

   地址转换：由page号查页表找到frame号，再乘页表项（page）大小得页面起始地址

   硬件支持：1. 由于页表实际存放于内存中，且每一进程都有页表。则页表的基地址和长度需要放入寄存器以用于快速查找：PTBR、PTLR 

   **注：这些寄存器的值在context switch时也要放入PCB

   2. Page table访问需要两次，为加速。提供一种cache方案：TLB放置页表的缓存内容
   3. ASID地址空间标识符，当TLB条目缓存来自不同虚拟地址的页表条目时用于保护各地址空间，当硬件不支持ASID时，context switch需要清空TLB

​	**注：分页对用户不可见，分段对用户可见；分段更容易实现信息的共享和保护；分段是逻辑划分

5. 页表结构：

   1. 分层页表：整个页表过大，无法在一个frame中存储，所以采用分级页表

      ​					地址结构：一级页号 + 二级页号 + 页偏移

   2. 哈希页表：每个页表项为（虚拟页码+frame码+指向下个同hash value的项的指针）

   3. 倒置页表



​				



