RAII

1. 构造函数：

   a. 自定义构造函数构造函数：

   ​	自定义构造函数可以有任意个参数，类成员变量通过初始化表达式初始：

   ```c++
   Pig(std::string name,int weight = 100) : mName(name), mWeight(weight) {
       //构造函数剩余部分
   }
   ```

   **自定义构造函数存在一个隐式调用问题：

   ```c++
   Pig p = {"name",1};  //implicit Pig("name",1)
   Pig p = "a";		//implicit Pig("a",100)
   ```

   即若可以找到匹配的构造函数，编译器在这种使用{}的初始化列表或单变量的情况下，会隐式得调用构造函数。当然这样的隐式构造往往是我们不需要的，所以可以使用explicit关键字禁止隐式构造

   当然，{}这中初始话列表方式也有好处：

   1. 解决函数返回结构体的问题：

      ```c++
       Intersection intersect(Ray ray){
       	...
       	return {ray.origin,ray.dir,t,isHit};
       }  //可以使用{}直接构造要返回的结构，而无需再显示的构造新的结构体再赋值
      ```

   2. 解决复杂的函数参数：

      ```c++
      void func(std::tuple<int,float,std::string> arg,std::vector<int> arr){
      	...
      }
      int main(){
          func({1,1.0,"213"},{1,2,3,4,5});
      } //函数调用时可以使用{}构造复杂的参数
      ```

   

   b. 拷贝构造函数

   拷贝构造函数的参数是一个Pig类型的常量引用：
   ```c++
   Pig(const Pig& other);
   ```
   
   除拷贝构造外还有一种拷贝赋值函数：
   
   ```c++
   Pig& operator=(const Pig& other);
   ```
   
   **如何判断是使用了拷贝构造还是拷贝赋值？
   
   拷贝构造作用是在变量**尚未**初始化时，将另一个变量拷贝进来`Pig p = pig2`
   
   而拷贝赋值时在变量**已经**初始化过后，销毁当前变量，同时拷贝另一个变量`Pig p; p = pig2`
   
   拷贝准则：
   
   默认生成的拷贝构造函数只会复制一个类对象的内存印象到另一个类对象。也就是说，对指针或引用类型的拷贝是浅拷贝（没有真正复制内容）这时候析构函数如果释放掉指针则可能出现double free的问题。拷贝赋值也是同理。因此我们规定：
   
   > **三五法则1**：一个类如果定义了析构函数则必须定义或删除拷贝构造函数
   >
   > **三五法则2**： 一个类如果定义了拷贝构造函数必须定义或删除拷贝赋值函数
   
   
   
   c. 移动构造函数
   
   
   
   在讨论移动构造函数之前先讨论左值和右值：
   
   C++左值右值分类：
   
   左值(left value)：对于一个表达式，在执行语句处如果我们可以取到这个表达式的地址，则为左值
   
   纯右值(pure right value): 对于一个表达式，在执行语句处，如果我们无法取到这个表达式的地址(字面常数或无名临时变量)，同时该右值的资源不会被其他对象重新使用（即不会被其他对象移动赋值或移动构造），则为纯右值
   
   将亡值(expiring value): 对于一个右值，如果它的资源马上会被重新利用（会被其他对象移动赋值或移动构造），则为将亡值
   
   泛左值(generalized lvalue): lvalue + xvalue
   
   右值(right value): rvalue + xvalue
   
   例子：
   
   ```c++
   int &&r; r: //lvalue
   static_cast<char&>(x) //lvalue
   ++a //lvalue
   
   a++ //prvalue
   &a //prvalue
   
   std::move(x)     //xvalue
   static_cast<char&&>(x) //xvalue
   
   int F() //prvalue
   int& F() //lvalue
   int&& F() //xvalue
   ```
   
   
   
   移动构造：移动构造要求传递右值引用(可由右值隐式转换)，新构造的接管传递而来对象的内存并在移动之后把源对象销毁，开销小。
   
   ```
   Pig(Pig&& other);
   ```
   
   同理还有移动赋值：
   
   ```
   Pig& operator=(Pig&& other);
   ```
   
   一般在以下的情况下会触发移动语义：
   
   ```c++
   return v2;     //返回非左值引用的函数的返回值
   v1 = Pig{"name",1};  //构造无名临时变量
   v1 = std::move(v);	//move语义
   ```
   
   移动准则：

>**三五法则3**：一个类如果定义了移动构造函数则必须定义或删除移动赋值函数
>
>**三五法则4**： 一个类如果定义了拷贝构造函数或拷贝赋值函数，那么必须最好同时定义移动构造			函数或移动赋值函数